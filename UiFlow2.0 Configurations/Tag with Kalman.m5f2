{"version":"V2.0","versionNumber":"V2.3.4","type":"stickc-plus2","components":[{"name":"screen","type":"screen","layer":0,"screenId":"builtin","screenName":"","id":"__stickc-plus2_screen","createTime":1756974471447,"x":0,"y":0,"width":135,"height":240,"backgroundColor":"#000000","size":0,"isSelected":true}],"resources":[{"hardware":["hardware_button","hardware_pin_button","imu","speaker","ir"]},{"unit":["unit_uwb"]}],"units":[{"type":"unit_uwb","name":"uwb_0","portList":["A","Custom"],"portType":"A","userPort":[22,21],"id":"hpQ1-s80tyno5Aid","createTime":1757146178161,"initBlockId":"bn6xLTDkI|{m5IsRI3vD"}],"hats":[],"bases":[],"i2cs":[],"blockly":"<block type=\"basic_on_setup\" id=\"setup_block\" deletable=\"false\" x=\"50\" y=\"50\"><mutation isBegin=\"true\"></mutation><field name=\"UPDATEOP\">true</field><statement name=\"FUNC\"><block type=\"system_m5_begin\" id=\"V!kJY0L/H8uQtx|FMOUv\"><next><block type=\"unit_uwb_init\" id=\"bn6xLTDkI|{m5IsRI3vD\"><mutation mode=\"tag\"></mutation><field name=\"NAME\">uwb_0</field><field name=\"MODE\">tag</field><field name=\"VERBOSE\">False</field><value name=\"UART\"><shadow type=\"unit_uwb_id_option\" id=\"mz{b5#1S!7lsdwUiKrD_\"><field name=\"VALUE\">2</field></shadow></value><value name=\"ID\"><shadow type=\"math_number\" id=\"UpUZk!++Gh3j{x^OOd}E\"><mutation max=\"Infinity\" min=\"-Infinity\" precision=\"0\"></mutation><field name=\"NUM\">0</field></shadow></value></block></next></block></statement></block><block type=\"basic_on_loop\" id=\"loop_block\" deletable=\"false\" x=\"450\" y=\"50\"><mutation isUpdate=\"true\"></mutation><field name=\"UPDATEOP\">true</field><statement name=\"FUNC\"><block type=\"system_m5_update\" id=\"p5U?(1[3Ou};Yds4YH:?\"></block></statement></block>","screen":[{"simulationName":"Built-in","type":"builtin","width":135,"height":240,"scale":0.67,"screenName":"","blockId":"","screenColorType":0,"rotation":0,"id":"builtin","createTime":1756974471447}],"logicWhenNum":0,"pythonCode":"import time, math\nimport network\nimport requests\nimport M5\nfrom M5 import *\nfrom unit import UWBUnit\n\nWIFI_SSID = 'iPhone di Marcos'\nWIFI_PASSWORD = 'tierloop'\nSERVER_URL = 'http://172.20.10.2:5050/log'\n\nANCHORS = [\n    (0.0, 0.0),\n    (1.7, 0.0),\n    (0.0, 6.3),\n    (1.7, 6.3)\n]\n\n# Moving average window (per-ancora)\nMA_WINDOW = 5\n\n# EKF params\nDT = 0.2  # loop period (s), must match sleep time\nSIGMA_A = 0.8  # m/s^2, expected accel std (tuning)\nSIGMA_R_DEFAULT = 0.2  # m, measurement noise std per anchor default (tuning)\nMAHAL_THR_MULT = 6.0  # gating threshold multiplier (tuning - see comments)\n\n# Minimal number of anchors for update (at least 3 for 2D)\nMIN_ANCHORS_FOR_POS = 3\n\n# UI refresh / loop timing (ms)\nLOOP_MS = int(DT*1000)\n\ndef mat_add(A, B):\n    return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n\ndef mat_sub(A, B):\n    return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))]\n\ndef mat_mul(A, B):\n    # A: n x p, B: p x m -> result n x m\n    n = len(A); p = len(A[0]); m = len(B[0])\n    C = [[0.0]*m for _ in range(n)]\n    for i in range(n):\n        for k in range(p):\n            aik = A[i][k]\n            if aik == 0.0:\n                continue\n            rowB = B[k]\n            for j in range(m):\n                C[i][j] += aik * rowB[j]\n    return C\n\ndef mat_transpose(A):\n    return [list(row) for row in zip(*A)]\n\ndef scalar_mul(A, s):\n    return [[A[i][j]*s for j in range(len(A[0]))] for i in range(len(A))]\n\ndef eye(n, eps=0.0):\n    return [[(1.0 if i==j else 0.0) + (eps if i==j else 0.0) for j in range(n)] for i in range(n)]\n\ndef vec_add(a, b):\n    return [a[i]+b[i] for i in range(len(a))]\n\ndef vec_sub(a, b):\n    return [a[i]-b[i] for i in range(len(a))]\n\ndef vec_dot(a, b):\n    return sum(a[i]*b[i] for i in range(len(a)))\n\n# invert small matrix via Gauss-Jordan (square)\ndef mat_inv(A):\n    n = len(A)\n    # build augmented\n    M = [list(A[i]) + [0.0]*n for i in range(n)]\n    for i in range(n):\n        M[i][n+i] = 1.0\n    # forward elimination\n    for i in range(n):\n        # pivot\n        pivot = M[i][i]\n        if abs(pivot) < 1e-12:\n            # try to swap with a lower row\n            for k in range(i+1, n):\n                if abs(M[k][i]) > 1e-12:\n                    M[i], M[k] = M[k], M[i]\n                    pivot = M[i][i]\n                    break\n            else:\n                raise ValueError(\"Matrix singular for inversion\")\n        # normalize row\n        inv_p = 1.0 / pivot\n        for j in range(2*n):\n            M[i][j] *= inv_p\n        # eliminate others\n        for r in range(n):\n            if r == i:\n                continue\n            factor = M[r][i]\n            if factor == 0.0:\n                continue\n            for c in range(i, 2*n):\n                M[r][c] -= factor * M[i][c]\n    # extract inverse\n    Inv = [row[n:] for row in M]\n    return Inv\n\n# solve linear system A x = b where A is square n x n, b is vector len n\ndef solve_linear(A, b):\n    # augment and Gauss elimination\n    n = len(A)\n    M = [list(A[i]) + [b[i]] for i in range(n)]\n    # forward\n    for i in range(n):\n        pivot = M[i][i]\n        if abs(pivot) < 1e-12:\n            for k in range(i+1, n):\n                if abs(M[k][i]) > 1e-12:\n                    M[i], M[k] = M[k], M[i]\n                    pivot = M[i][i]\n                    break\n            else:\n                raise ValueError(\"Singular matrix in solve\")\n        invp = 1.0 / pivot\n        for j in range(i, n+1):\n            M[i][j] *= invp\n        for r in range(n):\n            if r == i:\n                continue\n            f = M[r][i]\n            if f == 0.0:\n                continue\n            for c in range(i, n+1):\n                M[r][c] -= f * M[i][c]\n    return [M[i][n] for i in range(n)]\n\nclass MovingAverage:\n    def __init__(self, N):\n        self.N = max(1, int(N))\n        self.buf = []\n    def add(self, v):\n        self.buf.append(v)\n        if len(self.buf) > self.N:\n            self.buf.pop(0)\n    def mean(self):\n        if not self.buf:\n            return None\n        return sum(self.buf) / len(self.buf)\n    def ready(self):\n        return len(self.buf) >= 1\n\nclass EKF2D:\n    def __init__(self, dt, sigma_a=SIGMA_A):\n        # state: [x, y, vx, vy]\n        self.dt = dt\n        self.x = [0.0, 0.0, 0.0, 0.0]\n        # P init: moderately uncertain in position\n        self.P = [[1.0,0,0,0],\n                  [0,1.0,0,0],\n                  [0,0,1.0,0],\n                  [0,0,0,1.0]]\n        self.sigma_a = sigma_a\n        self._update_Q()\n    def _update_Q(self):\n        dt = self.dt\n        s2 = self.sigma_a**2\n        self.Q = [\n            [s2*(dt**4)/4.0, 0.0, s2*(dt**3)/2.0, 0.0],\n            [0.0, s2*(dt**4)/4.0, 0.0, s2*(dt**3)/2.0],\n            [s2*(dt**3)/2.0, 0.0, s2*(dt**2), 0.0],\n            [0.0, s2*(dt**3)/2.0, 0.0, s2*(dt**2)]\n        ]\n    def predict(self):\n        x, y, vx, vy = self.x\n        dt = self.dt\n        # state prediction\n        self.x = [x + vx*dt, y + vy*dt, vx, vy]\n        # F matrix\n        F = [[1,0,dt,0],[0,1,0,dt],[0,0,1,0],[0,0,0,1]]\n        # P = F P F^T + Q\n        FP = mat_mul(F, self.P)\n        FPFt = mat_mul(FP, mat_transpose(F))\n        self.P = mat_add(FPFt, self.Q)\n    def get_predicted_ranges(self, anchors):\n        # compute predicted ranges to anchors using predicted state (x,y)\n        x, y = self.x[0], self.x[1]\n        ranges = []\n        for ax, ay in anchors:\n            ranges.append(math.hypot(x-ax, y-ay))\n        return ranges\n    def update_with_ranges(self, z_list, anchors, R_diag):\n        # z_list: list of measured ranges for corresponding anchors (m entries)\n        # anchors: list of coordinates\n        m = len(z_list)\n        # build h(x) and Jacobian H (m x 4)\n        hx = []\n        H = []\n        x_est, y_est = self.x[0], self.x[1]\n        for i in range(m):\n            ax, ay = anchors[i]\n            dx = x_est - ax\n            dy = y_est - ay\n            ri = math.hypot(dx, dy)\n            # avoid division by zero\n            if ri < 1e-6:\n                ri = 1e-6\n            hx.append(ri)\n            H.append([dx/ri, dy/ri, 0.0, 0.0])\n        # innovation y = z - h\n        y_vec = [[z_list[i] - hx[i]] for i in range(m)]  # m x 1\n        # S = H P H^T + R  (m x m)\n        H_mat = H  # m x 4\n        HP = mat_mul(H_mat, self.P)    # m x 4\n        HPHt = mat_mul(HP, mat_transpose(H_mat))  # m x m\n        # add R (diagonal)\n        for i in range(m):\n            HPHt[i][i] += R_diag[i]**2\n        S = HPHt\n        # gating: compute Mahalanobis distance delta = y^T S^{-1} y\n        try:\n            S_inv = mat_inv(S)\n            # compute delta scalar\n            temp = mat_mul(mat_transpose(y_vec), S_inv)  # 1 x m\n            delta = mat_mul(temp, y_vec)[0][0]\n        except Exception:\n            # if inversion fails, reject update\n            return False, \"S_inversion_failed\"\n        # threshold: we expect delta ~ chi2(df=m); use a safety multiplier\n        chi2_threshold = MAHAL_THR_MULT * m\n        if delta > chi2_threshold:\n            return False, \"gating_failed\"\n        # compute Kalman gain K = P H^T S^{-1}  -> (4 x m)\n        Ht = mat_transpose(H_mat)  # 4 x m\n        PHt = mat_mul(self.P, Ht)  # 4 x m\n        K = mat_mul(PHt, S_inv)    # 4 x m\n        # state update x = x + K * y\n        Ky = mat_mul(K, y_vec)  # 4 x 1\n        self.x = [self.x[i] + Ky[i][0] for i in range(4)]\n        # covariance update P = (I - K H) P   (Joseph form more stable)\n        I = eye(4)\n        KH = mat_mul(K, H_mat)  # 4 x 4\n        IKH = mat_sub(I, KH)\n        P_new = mat_mul(mat_mul(IKH, self.P), mat_transpose(IKH))\n        # add K R K^T term (Joseph form)\n        KR = [[0.0]*m for _ in range(4)]\n        for i in range(4):\n            for j in range(m):\n                KR[i][j] = K[i][j] * (R_diag[j]**2)\n        KRKt = mat_mul(KR, mat_transpose(K))\n        self.P = mat_add(P_new, KRKt)\n        return True, {\"delta\": delta}\n    def get_state(self):\n        return tuple(self.x)\n    def set_state(self, x0, P0=None):\n        self.x = list(x0)\n        if P0 is not None:\n            self.P = [list(row) for row in P0]\n\n# ------ MAIN APPLICATION CODE --------\n# Global UI vars (kept minimal)\nuwb = None\nwlan = None\nma_buffers = []\nekf = None\n\ndef setup():\n    global uwb, wlan, ma_buffers, ekf\n    M5.begin()\n    Widgets.setRotation(3)\n    Widgets.fillScreen(0x000000)\n\n    Widgets.Label(\"UWB EKF Tag\", 10, 5, 1.2, 0xffffff, 0x000000, Widgets.FONTS.DejaVu18)\n\n    uwb = UWBUnit(2, port=(33, 32), device_mode=UWBUnit.TAG, verbose=True)\n    try:\n        uwb.set_measurement_interval(int(LOOP_MS))\n        uwb.set_measurement(True)\n    except Exception:\n        pass\n\n    ma_buffers = [MovingAverage(MA_WINDOW) for _ in ANCHORS]\n\n    # EKF initialization\n    ekf = EKF2D(dt=DT, sigma_a=SIGMA_A)\n    connect_wifi()\n\ndef connect_wifi():\n    global wlan\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(False)\n    time.sleep(0.5)\n    wlan.active(True)\n    if wlan.isconnected():\n        wlan.disconnect()\n        time.sleep(0.5)\n    wlan.connect(WIFI_SSID, WIFI_PASSWORD)\n    t0 = time.time()\n    while not wlan.isconnected():\n        time.sleep(0.2)\n        if time.time() - t0 > 15:  # increased timeout\n            print(\"Wi-Fi timeout, continuing without network\")\n            return\n    print(\"Wi-Fi connected:\", wlan.ifconfig())\n\ndef read_raw_distances():\n    \"\"\"Read raw distances from UWB device. Returns list (len=4) with None for missing.\"\"\"\n    d = []\n    for i in range(len(ANCHORS)):\n        try:\n            di = uwb.get_distance(i)\n            if di is None:\n                d.append(None)\n            else:\n                d.append(float(di))\n        except Exception:\n            d.append(None)\n    return d\n\ndef read_quality_if_available(idx):\n    \"\"\"Try to read CIR/SNR/quality for anchor idx; return None if not available.\"\"\"\n    try:\n        if hasattr(uwb, \"get_quality\"):\n            q = uwb.get_quality(idx)\n            return q\n        # else try other fields\n        if hasattr(uwb, \"get_cir\"):\n            return uwb.get_cir(idx)\n    except Exception:\n        pass\n    return None\n\ndef trilateration_linear(dists, anchors):\n    \"\"\"Linear LS trilateration using anchor 3 as reference (like your calculate_position_4).\n       Accepts list of distances (with None for missing). If fewer than 3 valid anchors, return None.\n    \"\"\"\n    # collect valid anchors\n    valid = [(i, dists[i], anchors[i]) for i in range(len(dists)) if dists[i] is not None]\n    if len(valid) < MIN_ANCHORS_FOR_POS:\n        return None\n    idxs = [v[0] for v in valid]\n    ref_idx = idxs[-1]\n    x4, y4 = anchors[ref_idx]\n    d4 = dists[ref_idx]\n    rows = []\n    bs = []\n    for (i, di, (xi, yi)) in valid:\n        if i == ref_idx:\n            continue\n        Ai = [2*(xi - x4), 2*(yi - y4)]\n        bi = (di*di - d4*d4 - xi*xi + x4*x4 - yi*yi + y4*y4)\n        rows.append(Ai)\n        bs.append([bi])\n    At = mat_transpose(rows)  # 2 x (n-1)\n    AtA = mat_mul(At, rows)   # 2 x 2\n    Atb = mat_mul(At, bs)     # 2 x 1\n    try:\n        sol = solve_linear(AtA, [Atb[0][0], Atb[1][0]])\n        return sol[0], sol[1]\n    except Exception:\n        return None\n\ndef adaptive_R_from_quality(qualities):\n    \"\"\"Return R_diag list from qualities (if None, use default). We map quality to std via heuristic.\"\"\"\n    R = []\n    for q in qualities:\n        if q is None:\n            R.append(SIGMA_R_DEFAULT)\n        else:\n            try:\n                qf = float(q)\n                # map: q >= 80 -> 0.12m , q<=30 -> 0.6m linearly\n                if qf >= 80:\n                    R.append(0.12)\n                elif qf <= 30:\n                    R.append(0.6)\n                else:\n                    # linear interp between 0.6 and 0.12\n                    s = (qf - 30.0) / (80.0 - 30.0)\n                    R.append(0.6*(1-s) + 0.12*s)\n            except Exception:\n                R.append(SIGMA_R_DEFAULT)\n    return R\n\ndef main_loop():\n    global ekf\n    last_trilat_time = 0\n    while True:\n        t_loop = time.ticks_ms()\n        # read raw distances\n        raw_d = read_raw_distances()  # list len 4\n        # read quality if possible\n        qualities = [read_quality_if_available(i) for i in range(len(ANCHORS))]\n        # apply moving average per anchor\n        filtered = [None]*len(ANCHORS)\n        for i, val in enumerate(raw_d):\n            if val is not None and (not math.isfinite(val) or val <= 0.0):\n                val = None\n            if val is not None:\n                ma_buffers[i].add(val)\n            if ma_buffers[i].ready():\n                filtered[i] = ma_buffers[i].mean()\n            else:\n                filtered[i] = None\n        # attempt trilateration every loop if possible to get an initial or direct position estimate\n        trilat = trilateration_linear(filtered, ANCHORS)\n        # if we have trilateration and EKF not yet initialized with meaningful pos, set state\n        if trilat is not None and (ekf is not None):\n            # preference: if EKF hasn't been \"initialized\" (P pos diag large) or if some time passed, re-initialize pos\n            x_t, y_t = trilat\n            # set EKF position if first time (we check P position variance)\n            if ekf.P[0][0] > 5.0 or (time.time() - last_trilat_time) > 5.0:\n                ekf.x[0] = x_t\n                ekf.x[1] = y_t\n                ekf.x[2] = 0.0\n                ekf.x[3] = 0.0\n                # tighten position variance a bit because trilateration gives direct info\n                ekf.P[0][0] = 0.5; ekf.P[1][1] = 0.5\n                last_trilat_time = time.time()\n        # EKF predict\n        try:\n            ekf.predict()\n        except Exception as e:\n            print(\"EKF predict error:\", e)\n        # Prepare measurement update if we have at least MIN_ANCHORS_FOR_POS filtered distances\n        present_idxs = [i for i,d in enumerate(filtered) if d is not None]\n        if len(present_idxs) >= MIN_ANCHORS_FOR_POS:\n            # build measurement vectors and corresponding anchors in the same order\n            z_list = [filtered[i] for i in present_idxs]\n            anchors_sub = [ANCHORS[i] for i in present_idxs]\n            qualities_sub = [qualities[i] for i in present_idxs]\n            R_diag = adaptive_R_from_quality(qualities_sub)\n            # NLOS/outlier: quick heuristic - if measured range deviates > 1.5 m from predicted range, mark as NLOS and inflate R\n            pred_ranges = ekf.get_predicted_ranges(anchors_sub)\n            for j in range(len(z_list)):\n                if pred_ranges[j] is not None:\n                    if abs(z_list[j] - pred_ranges[j]) > 1.2:  # heuristic threshold (tune)\n                        # inflate measurement std to reduce weight\n                        R_diag[j] = max(R_diag[j], 1.0)\n            # EKF update\n            try:\n                ok, info = ekf.update_with_ranges(z_list, anchors_sub, R_diag)\n                if not ok:\n                    if info == \"gating_failed\":\n                        # inflate R and retry\n                        R_diag2 = [r*4.0 for r in R_diag]\n                        try:\n                            ok2, info2 = ekf.update_with_ranges(z_list, anchors_sub, R_diag2)\n                            if not ok2:\n                                print(\"EKF update still rejected:\", info2)\n                            else:\n                                pass  # accepted after inflation\n                        except Exception as e:\n                            print(\"EKF update retry error:\", e)\n                    else:\n                        print(\"EKF update rejected:\", info)\n            except Exception as e:\n                print(\"EKF update exception:\", e)\n        # get final state and optionally send\n        x, y, vx, vy = ekf.get_state()\n        # simple UI print\n        print(\"POS: {:.3f},{:.3f}  V: {:.3f},{:.3f}\".format(x, y, vx, vy))\n        # prepare payload: include filtered distances, raw distances, quality, EKF covariance diag\n        payload = {\n            \"x\": x, \"y\": y,\n            \"dist0\": filtered[0],\n            \"dist1\": filtered[1],\n            \"dist2\": filtered[2],\n            \"dist3\": filtered[3]\n        }\n        # send asynchronously via HTTP (best-effort)\n        try:\n            resp = requests.post(SERVER_URL, json=payload, timeout=1.0)\n            resp.close()\n        except Exception as e:\n            # no network or timeout; ignore\n            pass\n        # loop timing\n        t_elapsed = time.ticks_diff(time.ticks_ms(), t_loop)\n        sleep_ms = max(10, LOOP_MS - t_elapsed)\n        time.sleep_ms(sleep_ms)\n\nif __name__ == \"__main__\":\n    try:\n        setup()\n        main_loop()\n    except KeyboardInterrupt:\n        print(\"Stopped by user\")\n    except Exception as e:\n        print(\"Fatal error:\", e)","customList":[]}